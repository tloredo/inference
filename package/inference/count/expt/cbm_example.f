c-----------------------------------------------------------------------	function ctllike (d)c---	"CounTs Log LIKElihood"cc	Return the log likelihood for dataset d, whichc	must contain counts from bin or channel samples.cc	NOTE:  Parts of the variance calculation are duplicated inc	ctvar, below.c+++  Arguments:	real*8 ctllike	integer dc+++  Globals:	include 'data.cb'	include 'lkcalc.cb'c+++  Locals:	integer i, j, n_on, n_off, nt, nneg	real*8 s, lscl, bgtot, ta_on, ta_off, slk, bhat, varb, var, pcts	real*8 one	parameter (one = 1.)c+++  Functions:	real*8 brate, crate, blrate, sl_scl, sllike, gammlnc---  Loop thru the samples, using the likelihood or an approximation.	ctllike = 0.	nneg = 0	do 100 i=1, nsmpls(d)c===  Skip sample, if not to be used.	    if (.not. usesmp(i,d)) goto 100c===  First just get the count rate from the signal, and accumulatec===  the background, since all likelihoods assume constant bg.c===  Also, compute t_on and t_off, which must include area as wellc===  as live time factors.	    if (dtype(d) .eq. 2) then	        s = brate(i,d)	    else if (dtype(d) .eq. 3) then	        s = crate(i,d)	    else if (dtype(d) .eq. 7) then	        s = blrate(i,d)	    endif	    ta_on = slive(d)*sarea(d)	    bgtot = 0.	    ta_off = 0.	    do 20 j=1, nbgint(d)	        bgtot = bgtot + bgsamp(i,j,d)	        ta_off = ta_off + bglive(j,d)*bgarea(j,d)20	    continuec===  Here's the Poisson likelihood (for no background), or thec===  Poisson quasilikelihood, assuming constant bg.  For the latter,c===  first get a scale to prevent overflow, then calculatec===  the likelihood, then remove the scale.c===  But before doing anything, make sure s>=0.  If not, skip thisc===  sample, but note that it was negative for later.  Put thisc===  check just after the previous block-if if you want it to workc===  for chi**2 approximations as well.	    if (approx .eq. 0) then	        if (s .lt. 0.) then	            nneg = nneg + 1	            goto 100	        endif	        if (nbgint(d) .eq. 0) then	            ctllike = ctllike - s*ta_on +     +                   ssamp(i,d)*log(s*ta_on) -     +                   gammln(ssamp(i,d)+one)	        else	            n_on = nint(ssamp(i,d))	            n_off = nint(bgtot)	            lscl = sl_scl(n_on, ta_on, n_off, ta_off)	            slk = sllike(s, n_on, ta_on, n_off, ta_off,      +                          lscl, pscut,nt)	            maxpst = max(maxpst,nt)	            ctllike = ctllike + slk	        endifc===  Here's chi**2 with model or data variance.  Add log correctionc===  if requested.	    else	        if (nbgint(d) .eq. 0) then	            bhat = 0.	            varb = 0.	        else	            bhat = bgtot / ta_off	            varb = bhat / ta_off	        endif	        pcts = (s+bhat)*ta_on	        if (approx .eq. 1) then	            var = pcts + varb*ta_on**2	        else if (approx .eq. 2) then	            var = ssamp(i,d) + varb*ta_on**2	        else if (approx .eq. 3) then	            var = pcts + varb*ta_on**2	        endif	        ctllike = ctllike -      +                    0.5*( pcts - ssamp(i,d) )**2 / var	        if (approx .eq. 3) then	            ctllike = ctllike - 0.5*log(pcts)	        endif	    endif100	continuec---  Here we make an adjustment if there were negative signals,c---  adding a large negative value to the likelihood.  Technically,c---  the prior should have prevented us from getting here, butc---  this should drive us back to the legal parameter range.c---  This formula is pretty arbitrary; it just subtracts off a largec---  value proportional to the current value, and then an additionalc---  value in case ctllike ~ 0.	if (nneg .gt. 0) then	    ctllike = ctllike - 10.*nneg*abs(ctllike) - 100.	endif	return	endc===================== data.par ========================================c-----------------------------------------------------------------------cc       This file defines parameters used to specify data storage.c       The meanings of the parameters follow.  It also containsc	a single global variable, placed here for access byc	modsyms.cb.cc-----------------------------------------------------------------------c       **********  Integer Parameters  **********c-----------------------------------------------------------------------cc       maxds		Maximum number of datasets.cc       maxsmp		Maximum number of samples in a dataset.c	                MAKE SURE THIS IS >= nchmax IN RFUNCS.PAR! cc	maxbgi		Maximum number of background intervals.cc-----------------------------------------------------------------------c       **********  Integer Scalar  **********c-----------------------------------------------------------------------cc       ndsets		Number of data sets entered.cc-----------------------------------------------------------------------c-----------------------------------------------------------------------	integer maxds, maxsmp, maxbgi	parameter (maxds = 5, maxsmp = 2500, maxbgi = 2)	integer ndsets	common /datcb0/ ndsetsc===================== data.cb =========================================c-----------------------------------------------------------------------cc       This file defines global variables used to store data.c	Data sets may be of three types:c	   location = Event locationsc	   bin      = Integer counts in simple binsc	   channel  = Integer counts in detector channels withc	             specified response functions.c	Also included are globals to store rates associated withc	data, so they need not be recalculated when not necessary.cc       The meanings of the variables follow.c-----------------------------------------------------------------------c       **********  Logical Arrays  **********c-----------------------------------------------------------------------cc       usesmp(i,k)	T if sample i in dataset k is not to be used,c                       F if sample i in dataset k is to be used.cc	qidone(k)	Indicates if the quadrature init has been c	                performed for dataset k.  It is only relevantc	                for channel data.cc	rtdone(i,k)	Indicates if event rate has been calculatedc	                for sample i of dataset k.cc	didtot(k)	Indicates if total rate has been calculatedc	                for dataset k, to avoid unnecessary recalc.c	                It is only relevant for location data.cc	bsflag(k)	Indicates if the source data in dataset k isc	                "background subtracted".  It is valid only forc	                Gaussian data types.  The "bs" prefix standsc	                for something *other* than "background c	                subtracted"!cc-----------------------------------------------------------------------c       **********  Integer Arrays  **********c-----------------------------------------------------------------------cc	dtype(k)	The data type for data set k:c			  1 = event locationsc			  2 = counts in simple binsc			  3 = counts in channelsc	                  4 = point samples with noisec	                  5 = binned sums with noisec	                  6 = channel sums with noisec			  7 = counts in blurred binsc			  8 = blurred sums with noisecc       nsmpls(k)	The number of samples in data set k.cc	nbgint(k)	The number of background intervals in dataset k.cc	rfsys(k)	The response function system associated withc	                channel samples in dataset k.c	c-----------------------------------------------------------------------c       **********  Real*8 Variables  **********c-----------------------------------------------------------------------ccc-----------------------------------------------------------------------c       **********  Real*8 Arrays  **********c-----------------------------------------------------------------------cc       range(2,k)	The range for point samples in dataset k.cc	bbound(2,i,k)	The boundaries for bins in dataset k.cc	psloc(i,k)	Locations for point samples in dataset k.cc	center(i,k)	The center location for Gaussian blurs in c			dataset k.cc	width(i,k)	The width (std deviation) for Gaussian blursc			in dataset k.cc       ssamp(i,k)	Source (bg+signal) sample i in dataset k.cc	svar(i,k)	Error variance for source sample i in dataset k,c	                for data with additive noise.cc	bsvar(i,k)	Part of error variance for source sample i in c                       dataset k, for "background-subtracted" data c                       with additive noise.cc	sepoch(k)	Epoch for source samples; used for BG corxn.cc	sdur(k)		Duration for source samples in dataset k.cc	slive(k)	"Live" duration for source samples.cc	sarea(k)	Area factor for source samples.  May = 1 ifc	                the response matrix is in units of area.cc       bgsamp(i,j,k)	Background sample i in bg interval j in set k.cc	bgvar(i,j,k)	Error variance for bg sample i in bg intervalc                       j for dataset k, for data with additive noise.cc	bgepoch(j,k)	Epoch for BG samples; used for BG corxn.cc	bgdur(j,k)	Duration for bg samples in interval j of set k.cc	bglive(j,k)	"Live" duration for bg samples.cc	bgarea(j,k)	Area factor for bg samples.cc	currt(i,k)	Current event rate for sample i, dataset k.cc	curtot(k)	Current total event rate in the range ofc	                dataset k; for point samples only.cc-----------------------------------------------------------------------c       **********  Character Array  **********c-----------------------------------------------------------------------cc	dsname(k)	Name associated with dataset k.cc-----------------------------------------------------------------------c-----------------------------------------------------------------------	include 'data.par'	integer dtype(maxds), nsmpls(maxds)	integer nbgint(maxds), rfsys(maxds)	real*8 range(2,maxds), bbound(2,maxsmp,maxds)	real*8 center(maxsmp,maxds), width(maxsmp,maxds)	real*8 psloc(maxsmp,maxds)	real*8 ssamp(maxsmp,maxds), sdur(maxds)	real*8 bgsamp(maxsmp,maxbgi,maxds), bgdur(maxbgi,maxds)	real*8 sepoch(maxds), bgepoch(maxbgi,maxds)	real*8 slive(maxds), bglive(maxbgi,maxds)	real*8 sarea(maxds), bgarea(maxbgi,maxds)	real*8 currt(maxsmp,maxds), curtot(maxds)	real*8 svar(maxsmp,maxds), bgvar(maxsmp,maxbgi,maxds)	real*8 bsvar(maxsmp,maxds)	logical qidone(maxds), rtdone(maxsmp,maxds), didtot(maxds)	logical usesmp(maxsmp,maxds), bsflag(maxds)	character*80 dsname(maxds)	common /datacb/ ssamp, sdur, bgsamp, bgdur, range, bbound,     *     center, width, psloc, sepoch, bgepoch, slive, bglive,      *     sarea, bgarea, currt, curtot, svar, bgvar, bsvar,     *     nbgint, rfsys, dtype, nsmpls,     *     qidone, rtdone, didtot, usesmp, bsflag	common /datccb/ dsnamec===================== data.cb =========================================c***********************************************************************cc	Globals specifying likelihood calculations.c	The maxds parameter in data.par is required.cc-----------------------------------------------------------------------c       **********  Logical Arrays  **********c-----------------------------------------------------------------------cc	lkdone(k)	Indicates whether the contribution of datasetc	                k to the joint likelihood has been calculated.cc-----------------------------------------------------------------------c       **********  Integer Scalars  **********c-----------------------------------------------------------------------cc	approx		Indicates whether an approximate likelihoodc	                should be used, and which approximation:c	                    0 = no approximation (Poisson)c	                    1 = Gaussian (chi**2), variance from modelc	                    2 = Gaussian (chi**2), variance from datac	                    3 = Gaussian (chi**2), variance from modelc	                        with logarithmic correctioncc	maxpst		Maximum number of Poisson series terms usedc	                to calculate the Poisson likelihood; kept soc	                user can monitor how expensive calculation isc	                at a given accuracy.cc	bsvtype		Indicates how to calculate the variance forc			"background-subtracted" Gaussian data.c			    1 = bg contribution + signal part from modelc			    2 = bg contribution + signal part from datacc-----------------------------------------------------------------------c       **********  Real*8 Scalars  **********c-----------------------------------------------------------------------cc	pscut		Poisson series cutoff.  Terms in the Poissonc	                series for the Poisson likelihood are kept upc	                to this factor times the leading term.cc-----------------------------------------------------------------------c       **********  Real*8 Arrays  **********c-----------------------------------------------------------------------cc	llkval(k)	The last calculated log likelihood value from c	                dataset k.cc-----------------------------------------------------------------------c-----------------------------------------------------------------------	integer approx, maxpst, bsvtype	real*8 llkval(maxds), pscut	logical lkdone(maxds)	common /lkclcb/ llkval, pscut, approx, maxpst, bsvtype, lkdone