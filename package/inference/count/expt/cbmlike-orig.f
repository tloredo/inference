c-----------------------------------------------------------------------cc	CBMLike:  Constant Background Marginal Likelihoodcc	Functions for calculating the Poisson likelihood forc	a signal rate when data are collected with a constantc	unknown background rate, estimated by observationsc	in "off-source" intervals.cc	The CBM likelihood is essentially equation (12.18) ofc	"The Promise of Bayesian Inference for Astrophysics"c	(in *Statistical Challenges in Modern Astronomy*, ed.c	E. Feigelson and G. Babu, Springer-Verlag, 1992,c	pages 275-305), but divided by "T_on" (that equationc	gives the posterior for the signal; these subroutinesc	calculate the likelihood; T_on simply normalizes thec	latter to produce the former when one uses a flat priorc	for the signal).cc	The data that the user must provide are:c	    n_on	Integer # of counts seen on-sourcec	    t_on	On-source interval size (eg time forc                       rate measurements, time*area for fluxc                       measurements)c	    n_off	Integer # of counts seen off-sourcec	    t_off	Off-source interval sizecc	The user must also set two parameters:c	    s		The signal strength for which the likelihoodc	                is to be calculatedc	    cut		A parameter specifying the accuracy ofc	                the calculation, in [0., 1.). cc	The calculation is done by summing terms in the sumc	given in equation (12.18) mentioned above.  If CUT = 0.,c	the sum is done with all (n_on + 1) terms, giving anc	exact result (to machine precision).  Otherwise, thec	sum starts with the largest term (call it LTERM), andc	adds decreasing terms until the new terms fall belowc	CUT*LTERM.  Terms in the sum are calculated recursively.cc	Note that the C_i factor in the sum is the probabilityc	that i of the n_on counts are actually from the signal,c	not the background.  For large values of n_on or n_off,c	many C_i coefficients will be negligibly small, possiblyc	causing an underflow.  There is no use keeping such terms,c	so I strongly recommend using CUT > 0.  This obviouslyc	also saves computational time, though in none of my ownc	applications has this likelihood calculation demandedc	excessive time (with, say, CUT = 1.e-5).cc	When the number of counts on- or off-source is large,c	the value of the likelihood can be very small, possiblyc	smaller than allowed by Fortran77 double precision.c	Thus these subroutines calculate a LOGARITHM of the c	SCALED likelihood.  The user must first calculate a scalec	factor using SL_SCL, and then calculate the scaled logc	likelihood using SLLIKE.  The scale factor depends onlyc	on the data, not on the values of S or CUT, hence thec	separate functions.  cc	Thus, once the data are known, the user should executec	the following:cc	    double precision sl_sclc	    double precision lscl, t_on, t_offc	    integer n_on, n_offcc	    lscl = sl_scl(n_on, t_on, n_off, t_off)cc	Then for each value of S for which the likelihood is needed,c	execute (for example):cc	    double precision sllikec	    double precision s, cut, sllc	    integer ntcc	    cut = 1.e-5c	    sll = sllike(s, n_on, ta_on, n_off, ta_off, lscl, cut, nt)cc	SLL will be the LOG of the SCALED likelihood.  If you needc	the actual value of the log likelihood for some reason,c	just add LSCL to SLL.  But since the value of LSCL dependsc	only on the data and not on the value of S, no commonc	calculations (parameter estimates, credible regions, Bayesc	factors, odds ratios) are afffected by using only thec	scaled value.cc	NT is set by the function and indicates the number of termsc	used in the calculation.  NT <= N_ON + 1.  It may be ofc	interest for monitoring how many terms are necessary atc	a particular level of accuracy (value of CUT).cc	If the user knows beforehand that scaling is not necessaryc	(e.g., the n_on and n_off values are relatively small),c	the small amount of overhead associated with sl_scl can bec	eliminated by eliminating the call to sl_scl and simplyc	setting LSCL=0.cc	If the derivative of the scaled log likelihood wrt S is alsoc	needed, use the following in place of the last set ofc	Fortran77 lines:cc	    double precision s, cut, sll, dsllc	    integer ntcc	    cut = 1.e-5c	    call cbmlike (s, n_on, ta_on, n_off, ta_off, lscl, cut, c	                  sll, dsll, nt)cc	SLL is as above; DSLL is its derivative wrt S.cc	Note that these functions are DOUBLE PRECISION.cc	Also, note that these functions call a function, GAMMLN,c	that returns the log of the gamma function.  This must bec	a real*8 function of a real*8 argument.  An appropriatec	implementation is the GAMMLN function in the "Numericalc	Recipes" books, changed to be real*8.cc	Algorithm and code by Tom Loredo, 1992.c	Modifications:c	    09 Apr 97:  Added documentation sectionc	    21 Apr 97:  Added derivative calculationc	    14 May 97:  Added remark about requiring GAMMLN to docscc-----------------------------------------------------------------------	function sl_scl (n_on, t_on, n_off, t_off)c---	"Signal Likelihood SCaLe"cc	Return the log of a scale factor for use in SLIKE, toc	prevent overflow/underflow.c+++  Arguments:	real*8 sl_scl, t_on, t_off	integer n_on, n_offc+++  Locals:	real*8 stt, nn, nns, disc, arg1, arg2, arg3	integer km	real*8 gammlnc---  The factor is just the largest term in the SLIKE series c---  for a value of s near the peak.  The logarithm is returned.c---  stt is the value of the signal, s, at the estimated peak,c---  times the sum of on and off times.	stt = (n_on/t_on - n_off/t_off)*(t_on + t_off)c---  Identify the index, km, for the largest term in the likelihoodc---  by solving a quadratic.	nn = n_on + n_off	nns = nn + stt - 1.	disc = nns*nns + 4.*(n_on + n_off - n_on*stt)	if (disc .ge. 0.) then	    km = 0.5* (nns - sqrt(disc)) + 1.	    km = min(km, n_on)	else	    km = n_on	endifc---  If km < 0, use the 0 term	if (km .le. 0) then	    arg2 = n_on + 1.	    arg1 = arg2 + n_off	    sl_scl = gammln(arg1) - gammln(arg2)	else	    arg2 = n_on - km + 1.	    arg1 = arg2 + n_off	    arg3 = km + 1.	    sl_scl = km*log(stt) + gammln(arg1) - gammln(arg2) -      +               gammln(arg3) - (n_on - n_off*t_on/t_off)	endif	return	endc-----------------------------------------------------------------------	function sllike (s, n_on, t_on, n_off, t_off, lscl, cut, nt)c---	"Signal Log LIKElihood"cc	Return the log likelihood for the signal, calculating with allc	terms up to a factor of CUT from the leading term.cc	LSCL is the log of a scale factor (see SL_SCL, above),c	used to prevent underflow/overflow.cc	On return, nt is the number of terms used; nt <= n_on+1.cc	This is NOT normalized w.r.t. s!  It's a log LIKELIHOOD, notc	a posterior density.cc	noff=0 gives nanc+++  Arguments:	real*8 sllike, s, t_on, t_off, lscl, cut	integer n_on, n_off, ntc+++  Locals:	real*8 slike, stt, nn, nns, disc	real*8 term, lterm, low, arg1, arg2, arg3	integer km, k	real*8 gammlnc---  Treat s=0 specially, to avoid log(0) calls.	nt = 1	if (s .eq. 0.) then	    arg1 = n_on + n_off + 1.	    arg2 = n_on + 1.	    sllike = gammln(arg1) - gammln(arg2) - lscl	    return	endifc---  Begin by finding the largest term.	stt = s * (t_on + t_off)	nn = n_on + n_off	nns = nn + stt - 1.	disc = nns*nns + 4.*(n_on + n_off - n_on*stt)	if (disc .ge. 0.) then	    km = 0.5* (nns - sqrt(disc)) + 1.	    km = min(km, n_on)	else	    km = n_on	endif	arg2 = n_on - km + 1.	arg1 = arg2 + n_off	arg3 = km + 1.	lterm = km*log(stt) + gammln(arg1) - gammln(arg2) -      +          gammln(arg3) - s*t_on - lscl	if (lterm .lt. -700. .or. lterm .gt. 700.) then	    slike = 0.	    print *, 'Under/overflow lterm in slike:'	    write(*,'(g12.4,2i6,2g12.4)') s, n_on, n_off, t_on, t_off	    pause 'Under/overflow in SLLIKE!'	else	    lterm = exp(lterm)	endif	low = cut * lterm	if (cut .gt. 0. .and. low .eq. 0.) then	    print *, 'Vanishing lterm in SLLIKE: ',     *         cut, lterm, cut*lterm	endifc----  First work down from the largest term.	slike = lterm	term = lterm	k = km20	    k = k - 1	    if (k .ge. 0.) then	        term = term * (nn - k) * (k + 1.) / (stt*(n_on - k))	        slike = slike + term	        nt = nt + 1	        if (term .gt. low) goto 20	    endifc---  Now work up from the largest term.	term = lterm	k = km40	    k = k + 1	    if (k .le. n_on) then	        term = term * stt * (n_on - k + 1.) / (k*(nn - k + 1.))	        slike = slike + term	        nt = nt + 1	        if (term .gt. low) goto 40	    endifc---  Take the log, and that's it!	sllike = log(slike)	return	endc-----------------------------------------------------------------------	subroutine cbmlike (s, n_on, t_on, n_off, t_off, lscl, cut,     *                      sll, dsll, nt)c---	"Constant Background Marginal LIKElihood"cc	Return the scaled log likelihood for the signal (SLL), c	calculating with all terms up to a factor of CUT from the c	leading term.  Also calculate the derivative of SLLc	with respect to s (returned as DSLL).cc	LSCL is the log of a scale factor (see SL_SCL, above),c	used to prevent underflow/overflow.cc	On return, nt is the number of terms used; nt <= n_on+1.cc	SLL is NOT normalized w.r.t. s!  It's a log LIKELIHOOD, notc	a posterior density.cc	noff=0 gives nanc+++  Arguments:	real*8 s, t_on, t_off, lscl, cut, sll, dsll	integer n_on, n_off, ntc+++  Locals:	real*8 slike, dsl, stt, nn, nns, disc	real*8 term, lterm, low, arg1, arg2, arg3	integer km, k	real*8 gammlnc---  Treat s=0 specially, to avoid log(0) calls.	nt = 1	if (s .eq. 0.) then	    arg1 = n_on + n_off + 1.	    arg2 = n_on + 1.	    sll = gammln(arg1) - gammln(arg2) - lscl	    arg1 = arg1 - 1.	    arg2 = arg2 - 1.	    term = log(1. + t_off/t_on) + gammln(arg1) - gammln(arg2)     *          - lscl	    dsll = t_on * (exp(term-sll) - 1.)	    return	endifc---  Begin by finding the largest term.	stt = s * (t_on + t_off)	nn = n_on + n_off	nns = nn + stt - 1.	disc = nns*nns + 4.*(n_on + n_off - n_on*stt)	if (disc .ge. 0.) then	    km = 0.5* (nns - sqrt(disc)) + 1.	    km = min(km, n_on)	else	    km = n_on	endif	arg2 = n_on - km + 1.	arg1 = arg2 + n_off	arg3 = km + 1.	lterm = km*log(stt) + gammln(arg1) - gammln(arg2) -      +          gammln(arg3) - s*t_on - lscl	if (lterm .lt. -700. .or. lterm .gt. 700.) then	    slike = 0.	    print *, 'Under/overflow lterm in cbmlike:'	    write(*,'(g12.4,2i6,2g12.4)') s, n_on, n_off, t_on, t_off	    pause 'Under/overflow in CBMLIKE!'	else	    lterm = exp(lterm)	endif	low = cut * lterm	if (cut .gt. 0. .and. low .eq. 0.) then	    print *, 'Vanishing lterm in CBMLIKE: ',     *         cut, lterm, cut*lterm        endif	dsl = lterm * (km/s - t_on)c----  First work down from the largest term.	slike = lterm	term = lterm	k = km20	    k = k - 1	    if (k .ge. 0.) then	        term = term * (nn - k) * (k + 1.) / (stt*(n_on - k))	        slike = slike + term	        dsl = dsl + term*(k/s - t_on)	        nt = nt + 1	        if (term .gt. low) goto 20	    endifc---  Now work up from the largest term.	term = lterm	k = km40	    k = k + 1	    if (k .le. n_on) then	        term = term * stt * (n_on - k + 1.) / (k*(nn - k + 1.))	        slike = slike + term	        dsl = dsl + term*(k/s - t_on)	        nt = nt + 1	        if (term .gt. low) goto 40	    endifc---  Take the log, and that's it!	dsll = dsl / slike	sll = log(slike)	return	end