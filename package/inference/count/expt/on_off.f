c-----------------------------------------------------------------------        subroutine setc(n_on, t_on, n_off, t_off, c, cdim)c---    Initialize the c array of coefficients in the Poisson seriesc       for the density of the signal.  The dimension of c(0:cdim)c	must be >= n_on + 1, and the first element should be c(0).cc	c(i) is the probability that i of the n_on counts are fromc	the background.cc	The coefficients are calculated recursively, going up andc	down from the largest one so roundoff error accumulates onlyc	on the negligible terms.        integer n_on, n_off, cdim, i, mode        real*8 t_on, t_off, c(0:cdim), tfac, sum, n        tfac = 1. + t_off/t_on        n = n_on + n_off        mode = n_on - t_on*n_off/t_off + 1.        mode = max(mode,0)        sum = 1.        c(mode) = 1.        do 20 i=mode-1, 0, -1            c(i) = c(i+1) * ( ((n - i)/(n_on - i)) / tfac )            sum = sum + c(i)20      continue        do 30 i=mode+1, n_on            c(i) = c(i-1) * (tfac * ((n_on - i + 1.)/(n - i + 1.)) )            sum = sum + c(i)30      continue        do 40 i=0, n_on            c(i) = c(i) / sum40      continue        return        endc-----------------------------------------------------------------------        subroutine ssetc(n_on, t_on, n_off, t_off, c, cdim)c---    Slower version of setc, calculating each coefficientc	directly with gamma function calls.        integer n_on, n_off, cdim, i        real*8 t_on, t_off, c(0:cdim), ltfac, sum, gammln, dum        ltfac = log(1. + t_off/t_on)        sum = 0.        do 20 i=0, n_on            dum = n_on - i + 1.            c(i) = i*ltfac + gammln(dum+n_off) - gammln(dum)            c(i) = exp(c(i))            sum = sum + c(i)20      continue        do 40 i=0, n_on            c(i) = c(i) / sum40      continue        return        endc-----------------------------------------------------------------------        subroutine esetc(n_on, t_on, n_off, t_off, c, cdim)c---	Similar to ssetc, but gives exact results for small integerc	n_on and n_off.        integer n_on, n_off, cdim, i, dum        real*8 t_on, t_off, c(0:cdim), tfac, sum, factrl        tfac = 1. + t_off/t_on        sum = 0.        do 20 i=0, n_on            dum = n_on - i            c(i) = tfac**i * (factrl(dum+n_off) / factrl(dum))            sum = sum + c(i)20      continue        do 40 i=0, n_on            c(i) = c(i) / sum40      continue        return        endc-----------------------------------------------------------------------        function psig(s, n_on, t_on, c, cdim)c---    Calculate the probability density for the signal, s.	integer n_on, cdim, i        real*8 psig, s, t_on, c(0:cdim), ppois	psig = 0.        do 20 i=0, n_on            psig = psig + c(i) * t_on * ppois(i, s*t_on)20      continue        return        endc-----------------------------------------------------------------------        subroutine sigsig(n_on, t_on, n_off, t_off, c, cdim,      +                    shi, p, iter)c---    Return the "significance" of a signal (the probability contentc       of a HPD region just including s = 0).cc	This assumes setc has already been called to set c.        integer n_on, n_off, cdim, iter, nrmax        real*8 t_on, t_off, c(0:cdim), shi, p, psig, ds, tol        real*8 mode, p0, s, sold, pcur, dpds        parameter (tol = 0.001d0, nrmax = 20)        real*8 eps, tnm, dp, sum        integer jmax, jmaxp, k, km, i, j, it        parameter(eps = 1.e-5, jmax=20, jmaxp=jmax+1, k=5, km=k-1)        real*8 papp(jmaxp), step(jmaxp)c---  Estimate the mode by subtracting rates.  If <= 0, return iter=-1.        mode = n_on/t_on - n_off/t_off        if (mode .le. 0.) then            iter = -1            return        endif        ds = 0.005d0 * modec---  What is the density at s=0?        p0 = psig(0.d0, n_on, t_on, c, cdim)c---  Use Newton-Raphson to find s where psig = p0.  Start at 2*mode.        iter = 0        s = 2.*mode        pcur = psig(s, n_on, t_on, c, cdim)20      sold = s        dpds = (psig(s+ds, n_on, t_on, c, cdim) - pcur) / ds        s = sold - (pcur-p0)/dpds        iter = iter + 1        pcur = psig(s, n_on, t_on, c, cdim)        if (abs(p0-pcur) .gt. tol*p0 .and. iter .lt. nrmax) go to 20        shi = s        if (iter .ge. 20) then            iter = -iter            return        endifc---  Integrate psig from 0 to shi with Romberg.        step(1) = 1.        do 11 j=1, jmax            if (j .eq. 1) then                papp(j) = 0.5*shi*(p0 + pcur)                it = 1            else                tnm = it                ds = shi / tnm                s = 0.5 * ds                sum = 0.                do 10 i=1, it                    sum = sum + psig(s, n_on, t_on, c, cdim)                    s = s + ds10              continue                papp(j) = 0.5*(papp(j) + shi*sum/tnm)                it = 2 * it            endif            if (j .ge. k) then                call polint(step(j-km), papp(j-km), k, 0.d0, p, dp)                if (abs(dp) .lt. eps*abs(p)) return            endif            papp(j+1) = papp(j)            step(j+1) = 0.25 * step(j)11      continuec---  If we get here, Romberg did not converge; return iter = 0.        iter = 0        return        endc-----------------------------------------------------------------------	function sl_scl (n_on, t_on, n_off, t_off)c---	"Signal Likelihood SCaLe"cc	Return the log of a scale factor for use in SLIKE, toc	prevent overflow/underflow.c+++  Arguments:	real*8 sl_scl, t_on, t_off	integer n_on, n_offc+++  Locals:	real*8 stt, nn, nns, disc, arg1, arg2, arg3	integer km	real*8 gammlnc---  The factor is just the largest term in the SLIKE series c---  for a value of s near the peak.  The logarithm is returned.	stt = (n_on/t_on - n_off/t_off)*(t_on + t_off)	nn = n_on + n_off	nns = nn + stt - 1.	disc = nns*nns + 4.*(n_on + n_off - n_on*stt)	if (disc .ge. 0.) then	    km = 0.5* (nns - sqrt(disc)) + 1.	else	    km = n_on	endif	if (km .le. 0) then	    arg2 = n_on + 1.	    arg1 = arg2 + n_off	    sl_scl = gammln(arg1) - gammln(arg2)	else	    arg2 = n_on - km + 1.	    arg1 = arg2 + n_off	    arg3 = km + 1.	    sl_scl = km*log(stt) + gammln(arg1) - gammln(arg2) -      +               gammln(arg3) - (n_on - n_off*t_on/t_off)	endif	return	endc-----------------------------------------------------------------------	function slike (s, n_on, t_on, n_off, t_off, lscl, cut, nt)c---	"Signal LIKElihood"cc	Return the likelihood for the signal, calculating with allc	terms up to a factor of CUT from the leading term.cc	LSCL is the log of a scale factor (see SL_SCL, above),c	used to prevent underflow/overflow.cc	On return, nt is the number of terms used; nt <= n_on+1.cc	This is NOT normalized w.r.t. s!c+++  Arguments:	real*8 slike, s, t_on, t_off, lscl, cut	integer n_on, n_off, ntc+++  Locals:	real*8 stt, nn, nns, disc, term, lterm, low, arg1, arg2, arg3	integer km, k	real*8 gammlnc---  Treat s=0 specially, to avoid log(0) calls.	nt = 1	if (s .eq. 0.) then	    arg1 = n_on + n_off + 1.	    arg2 = n_on + 1.	    slike = exp(gammln(arg1) - gammln(arg2) - lscl)	    return	endifc---  Begin by finding the largest term.	stt = s * (t_on + t_off)	nn = n_on + n_off	nns = nn + stt - 1.	disc = nns*nns + 4.*(n_on + n_off - n_on*stt)	if (disc .ge. 0.) then	    km = 0.5* (nns - sqrt(disc)) + 1.	else	    km = n_on	endif	arg2 = n_on - km + 1.	arg1 = arg2 + n_off	arg3 = km + 1.	lterm = km*log(stt) + gammln(arg1) - gammln(arg2) -      +          gammln(arg3) - lscl	if (lterm .lt. -700.) then	    slike = 0.	    return	else	    lterm = exp(lterm)	endif	low = cut * ltermc----  First work down from the largest term.	slike = lterm	term = lterm	k = km20	    k = k - 1	    if (k .ge. 0.) then	        term = term * (nn - k) * (k + 1.) / (stt*(n_on - k))	        slike = slike + term	        nt = nt + 1	        if (term .gt. low) goto 20	    endifc---  Now work up from the largest term.	term = lterm	k = km40	    k = k + 1	    if (k .le. n_on) then	        term = term * stt * (n_on - k + 1.) / (k*(nn - k + 1.))	        slike = slike + term	        nt = nt + 1	        if (term .gt. low) goto 40	    endifc---  Multiply by a common exp'l term, and that's it!	slike = slike * exp(-s*t_on)	return	end