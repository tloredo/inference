"""
Objects for calculating highest posterior density credible regions.

HPD1D and HPD2D find the boundaries of HPD regions using previously
calculated grids of 1-D or 2-D (log) probability densities (respectively).  They
are intended for use in settings where other tools will have already calculated
the grids (e.g., inference grids generated by PIE tools).  The pdf gets 
(re)normalized over the grid; e.g., the grids may contain values of an
unnormalized prior*likelihood (the normalization constant is accessible as a 
data attribute and may be useful for Bayesian model comparison).

See hpdgrid for versions that instead take probability density *functions*
and calculate the grids themselves.

By Tom Loredo
"""

from inference.utils.numutils import zbracket, lin_stepper, log_stepper
from scipy import exp, log, sqrt, pi, array, stats
from scipy.optimize import brentq
from ._gridquad import qgt1d, qgt2d, xvalues

__all__ = ['HPD1D', 'HPD2D']

rt2pi = sqrt(2*pi)
stdnorm = stats.norm()


def sig2prob(nd, nsig):
    """
    The probability within nsig std deviations of the mean of a n-dim normal
    distribution.
    """
    # For 1d the upper tail area is given by the std normal survival function.
    #utail = stdnorm.sf(nsig)
    # return 1. - 2*utail
    return stats.chi2.cdf(nsig**2, nd)


def prob2sig(nd, p):
    """
    The number of std deviations corresponding to probability p for n-dim normal.
    """
    # These two lines are for the 1-d normal case.
    #utail = 0.5*(1.-p)
    # return stdnorm.isf(utail)
    return sqrt(stats.chi2.ppf(p, nd))


def prob2dens(nd, p):
    """
    The n-dim normal PDF density bounding an HPD credible region of content p.
    """
    nsig = prob2sig(nd, p)
    return exp(-0.5*nd * nsig**2)/rt2pi**nd


def prob2ratio(nd, p):
    """
    The relative normal PDF density bounding an HPD credible region
    of content p (relative to the peak density).
    """
    nsig = prob2sig(nd, p)
    return exp(-0.5*nd * nsig**2)


def sig2ratio(nd, nsig):
    """
    The relative normal PDF density bounding an HPD credible region
    spanning nsig std deviations (relative to the peak density).
    """
    return exp(-0.5*nd * nsig**2)


class HPD1D(object):
    """
    Calculate 1-D HPD region boundaries from a grid of (log) pdf values.

    For grid spacing linear in x, the regions are for p(x).  For grid spacing 
    linear in log(x), the regions are for p(log x), but with boundaries
    specified in terms of x itself, i.e., appropriate for use on plots of 
    p(log x) (equal to x*p(x)) vs. x with a logarithmic abscissa.
    """

    # Probabilities associated with normal dist'n "sigmas":
    p1sig, p2sig, p3sig = sig2prob(1,1), sig2prob(1,2), sig2prob(1,3)

    # Corresponding relative PDF levels defining normal HPD regions,
    # to use as starting points:
    ratio1 = sig2ratio(1,1)
    ratio2 = sig2ratio(1,2)
    ratio3 = sig2ratio(1,3)

    def __init__(self, logpdf, xlo, xhi, step='linear'):
        """
        Initialize the HPDGrid1D object.

        :Parameters:

          logpdf : float array
            Array of log pdf values

          xlo, xhi : float
            Range spanned by logpdf

          step : 'linear' OR 'lin' OR 'logarithmic' OR 'log'
            'linear' for a grid linear in x; 'log' for a grid linear in log(x)
        """
        if len(logpdf.shape) != 1:
            raise ValueError('logpdf array must be 1-d!')
        self.logpdf = logpdf
        self.xlo, self.xhi = xlo, xhi
        self.nx = logpdf.shape[0]
        if step == 'linear' or step == 'lin':
            self.linstep = True
            self.xvals = array([x for x in lin_stepper(xlo, xhi, self.nx)])
            self.dx = (xhi-xlo)/(self.nx-1.)
        elif step == 'log' or step == 'logarithmic':
            self.linstep = False
            self.xvals = [x for x in log_stepper(xlo, xhi, self.nx)]
            self.dx = log(xhi/xlo)/(self.nx-1)
        else:
            raise ValueError('Invalid step type!')
        self.max = logpdf.max()
        self.spdf = exp(logpdf-self.max)  # scaled PDF
        # For log steps, change variables to log(x).
        if not self.linstep:
            for i, x in enumerate(self.xvals):
                self.spdf[i] = self.spdf[i]*x
        # Find the overall normalization for spdf.
        self.snorm = qgt1d(self.spdf, self.spdf.min())*self.dx
        # lml is the log marginal likelihood if logpdf = prior*like.
        self.lml = log(self.snorm) + self.max
        self.probs = []
        self.deltas = []
        self.levels = []
        self.bounds = []

    def norm(self):
        """
        Return the log of the normalization constant for the grid.

        If the log_pdf function is prior*likelihood, this is the marginal
        likelihood.
        """
        return log(self.snorm) + self.max

    def fracgt(self, logratio):
        """
        The fraction of the posterior with log density > maximum + logratio.
        """
        ratio = exp(logratio)
        return qgt1d(self.spdf, ratio)*self.dx/self.snorm

    def critlevel(self, p=None, snsig=None, tol=3.e-4):
        """
        The log critical PDF ratio (wrt mode) bounding an HPD credible region
        with probability p.
        """
        # Take as an initial guess the ratio for a 1-d normal.
        if snsig:
            if p:
                raise ValueError('Provide only one of p, snsig!')
            lr1 = log(sig2ratio(1, snsig))
            p = sig2prob(1, snsig)
        else:
            lr1 = log(prob2ratio(1, p))
        # Use the guess to bracket the solution and then solve.
        lr2 = lr1 - 0.1
        # print 'Guesses:', lr1, lr2
        self._target = p
        lr1, lr2 = zbracket(self._diff, lr1, lr2)
        # print 'Bracket:', lr1, lr2
        logratio = float(brentq(self._diff, lr1, lr2, xtol=tol))
        # print repr(logratio)
        self.probs.append(p)
        self.deltas.append(logratio)
        self.levels.append(self.max+logratio)
        # 10 is the max # boundaries; it should handle pretty bumpy PDFs!
        bounds, nb, ok = xvalues(self.xvals, self.logpdf-self.max, logratio, 10)
        if not ok:
            raise RuntimeError('Too many boundary points in PDF!')
        bounds = bounds[:nb]
        self.bounds.append(bounds)
        return logratio, bounds

    def _diff(self, logratio):
        """
        The function whose zero gives critRatio; it is fracgt - target prob.
        """
        return self.fracgt(logratio) - self._target


class HPD2D(object):
    """
    Calculate 2-D HPD region boundaries from a grid of (log) pdf values.
    """

    # Probabilities associated with normal dist'n "sigmas":
    p1sig, p2sig, p3sig = sig2prob(2,1), sig2prob(2,2), sig2prob(2,3)

    # Corresponding relative PDF levels defining normal HPD regions,
    # to use as starting points:
    ratio1 = sig2ratio(2,1)
    ratio2 = sig2ratio(2,2)
    ratio3 = sig2ratio(2,3)

    def __init__(self, logpdf, xlo, xhi, ylo, yhi, xstep='linear', ystep='linear'):
        if len(logpdf.shape) != 2:
            raise ValueError('logpdf array must be 2-d!')
        self.logpdf = logpdf
        self.xlo, self.xhi = xlo, xhi
        self.nx = logpdf.shape[0]
        if xstep == 'linear' or xstep == 'lin':
            self.xlinstep = True
            self.xvals = array([x for x in lin_stepper(xlo, xhi, self.nx)])
            self.dx = (xhi-xlo)/(self.nx-1)
        elif xstep == 'log' or xstep == 'logarithmic':
            self.xlinstep = False
            self.xvals = array([x for x in log_stepper(xlo, xhi, self.nx)])
            self.dx = log(xhi/xlo)/(self.nx-1)
        else:
            raise ValueError('Invalid xstep type!')
        self.ylo, selfyxhi = ylo, yhi
        self.ny = logpdf.shape[1]
        if ystep == 'linear' or ystep == 'lin':
            self.ylinstep = True
            self.yvals = array([y for y in lin_stepper(ylo, yhi, self.ny)])
            self.dy = (yhi-ylo)/(self.ny-1)
        elif ystep == 'log' or ystep == 'logarithmic':
            self.ylinstep = False
            self.yvals = array([y for y in log_stepper(ylo, yhi, self.ny)])
            self.dy = log(yhi/ylo)/(self.ny-1)
        else:
            raise ValueError('Invalid ystep type!')
        self.max = logpdf.max()
        self.spdf = exp(logpdf-self.max)  # Scaled PDF
        # For log steps, change variables to log(x or y).
        if not self.xlinstep:
            for i, x in enumerate(self.xvals):
                self.spdf[i,:] = self.spdf[i,:]*x
        if not self.ylinstep:
            for j, y in enumerate(self.yvals):
                self.spdf[:,j] = self.spdf[:,j]*y
        # Find the overall normalization for spdf.
        self.norm = qgt2d(self.spdf, self.spdf.min())*self.dx*self.dy
        # lml is the log marginal likelihood if logpdf = prior*like.
        self.lml = log(self.norm) + self.max
        self.probs = []
        self.deltas = []
        self.levels = []

    def fracgt(self, logratio):
        """
        The fraction of the posterior with log density > maximum + logratio.
        """
        ratio = exp(logratio)
        return qgt2d(self.spdf, ratio)*self.dx*self.dy/self.norm

    def critlevel(self, p=None, snsig=None, tol=3.e-4):
        """
        The log critical PDF ratio (wrt mode) bounding an HPD credible region
        with probability p.
        """
        # Take as an initial guess the ratio for a 1-d normal.
        if snsig:
            if p:
                raise ValueError('Provide only one of p, snsig!')
            lr1 = log(sig2ratio(1, snsig))
            p = sig2prob(1, snsig)
        else:
            lr1 = log(prob2ratio(1, p))
        p = float(p)  # Otherwise it may be a scalar array.
        # Use this to bracket the solution and then solve.
        lr2 = lr1 - 0.1
        # print 'Guesses:', lr1, lr2
        self._target = p
        lr1, lr2 = zbracket(self._diff, lr1, lr2)
        # print 'Bracket:', lr1, lr2
        logratio = float(brentq(self._diff, lr1, lr2, xtol=tol))
        # print repr(logratio)
        self.probs.append(p)
        self.deltas.append(logratio)
        self.levels.append(self.max+logratio)
        return logratio

    def _diff(self, logratio):
        """The function whose zero gives critRatio; it is fracgt - target prob."""
        return self.fracgt(logratio) - self._target
